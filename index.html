<head>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
        }
        .cell {
            background-color: white;
            width: 1px;
            height: 1px;
            display: inline-block;
        }
        .cell.active {
            background-color: black;
        }
    </style>
</head>
<body>
    <canvas id="world"></canvas>
    <script>
        const range = max => (new Array(max)).fill(0).map((v, i) => i)
        const mod = (n, m) => ((n % m) + m) % m
        const sample = arr => arr[Math.floor(Math.random() * arr.length)]
        const any = pred => coll => {
            for (let i = 0; i < coll.length; i ++) {
                if (pred(coll[i])) return true
            }
            return false
        }
        const seedSingle = len => {
            const lr = range(Math.floor(len / 2)).map(_ => 0)
            return [lr.concat(1).concat(lr)]
        }
        const seedRandom = len =>
            [range(len).map(_ => Math.floor(Math.random() * 2))]
        
        const evolver = rule => state => {
            const input = state[state.length - 1]
            const len = input.length
            const output = []

            for (let i = 0; i < len; i++) {
                output.push(rule(
                    input[mod(i - 1, len)],
                    input[i],
                    input[mod(i + 1, len)]
                ))
            }

            return state.concat([output])
        }
        
        const renderer = canvas => {
            const cellDim = 2
            const inactiveFill = '#FFFFFF'
            const activeFill = '#000000'
            const context = canvas.getContext('2d')
            const clear = _ => {
                context.fillStyle = '#FFFFFF'
                context.fillRect(0, 0, canvas.width, canvas.height)
            }
            const drawRow = (row, yOffset) => {
                for (let i = 0; i < row.length; i++) {
                    context.fillStyle = row[i] ? activeFill : inactiveFill
                    context.fillRect(i * cellDim, yOffset, cellDim, cellDim)
                }
            }

            canvas.width = window.innerWidth
            canvas.height = window.innerHeight
            
            return state => {
                clear()
                const startIdx = Math.max(
                    0, state.length - Math.floor(canvas.height / cellDim))
                for (let i = startIdx; i < state.length; i++) {
                    drawRow(
                        state[i], (canvas.height - ((state.length - i) * cellDim)))
                }
            }
        }

        const createRule = patterns => (a, b, c) => {
            const inPattern = [a, b, c].join('')
            const hasMatch = any(pattern => pattern === inPattern) 
            return hasMatch(patterns) ? 1 : 0
        }

        const rule18 = createRule(['100', '001'])
        const rule45 = createRule(['101', '011', '010', '000'])
        const rule57 = createRule(['101', '100', '011', '000'])
        const rule73 = createRule(['110', '011', '000'])
        const rule90 = createRule(['001', '100', '011', '001'])
        const rule160 = createRule(['111', '101'])
        const rule225 = createRule(['111', '110', '101', '000'])

        const rules = [rule18, rule45, rule57]

        // GO

        const render = renderer(document.getElementById('world'))

        let worldState = seedSingle(201)
        let evolve = evolver(sample(rules))
        let switchAccum = 0
        const update = _ => {
            if (switchAccum > 200) {
                switchAccum = 0
                evolve = evolver(sample(rules))
            }
            worldState = evolve(worldState)
            render(worldState)
            switchAccum++
        }

        const onframe = _ => {
            requestAnimationFrame(tick => {
                update(tick)
                onframe()
            })
        }

        onframe()
    </script>
</body>
